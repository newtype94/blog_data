---
title: 넓고 얕은 개념 정리 - 서버 편
date: 2019-09-10 13:11:11
tags:
  - 면접
category:
  - 면접 준비
  - 서버 편
---

> 본 페이지는 면접 속성 준비를 위하여 다양한 블로그를 참고했습니다.

## SOA와 MSA의 차이

SSG.COM 개발직 면접에서 질문받았다.
SOA라는 단어를 처음 들어 당황했다.
다른 면접관이 요즘에는 SOA를 안써서 잘 모를 수도 있다고 다독였으나, 결과는 탈락.

1. SOA 는 모듈의 의존성은 줄이되 모듈 내에서 공유할 수 있는건 최대한 공유하는 정책을 사용한다.
   반면, MSA 는 가능한 공유하지 않고 모듈들이 독립적으로 운용될 수 있도록 아키텍처를 디자인 한다.
2. SOA 는 서비스의 Flow 를 유지하려하지만, MSA 는 Flow 의 구별을 요구한다.
   가령, 서비스 내에서 결제를 하고자 할때, SOA 는 관련된 루틴을 수행하여 결제를 지원함으로써, 유저에게 제공해주는 "서비스" 를 1차 목적으로 한다.
   반면, MSA 는 유저에게 관련된 루틴과 결제 루틴을 별도로 이용하게끔 한다. 즉 서비스 내의 독립이 아닌 독립된 서비스를 지향한다.
   그렇다보니 SOA 아키텍처는 대게 어느정도 업격한 Protocol 과 Message 체계를 운용하게 되고, MSA 의 경우 별도의 체계가 없이 경량화된 프로토콜을 통해 운용되게 된다.
3. SOA 는 서비스들의 재사용에 중점을 두지만 MSA 는 서비스들의 독립을 추구한다.
   이는 블로그 내 다른 포스팅에서 언급한 적 있는 Monolithic Architecture 와 유사한 부분으로, SOA 는 MSA 에 비해 보다 Monolithic Architecture 에 가깝다.

## CI/CD

지속적인 통합(Continuous Integration) : 개발자를 위한 자동화 프로세스
지속적인 서비스 제공(Continuous Delivery)
지속적인 배포(Continuous Deployment)GitHub

## Redis와 Memchached

### Redis 장점

1. 디스크에 데이터를 기록한다.
2. Redis 메모리가 날라가도 데이터를 복구할 수 있다.
   (스냅샷을 떠서, 이를 사용하는 RDB 방식과 Write / Update Event를 로그에 남겨서 이를 기반으로 복구하는 AOF 방식 두가지가 있다.)
3. 다양한 데이터 포맷을 지원한다.
4. String, List, Set, Sorted sets, Hash 등의 데이터 포맷을 지원한다. 그래서 애플리케이션 단에서 편하게 데이터를 저장하고, 사용할 수 있다.
5. Memcached 보다 좀더 다양한 API를 지원한다.
6. 한 개의 키에 저장할 수 있는 VALUE의 범위가 Memcached에 비해 더 크다.
7. Redis는 512MB인 반면, memcached는 1MB까지 저장할 수 있다.

### Redis 단점

1. 메모리를 2배로 사용한다.
2. 레디스는 싱글 스레드이다. 그래서 스냅샷을 뜰 때, 자식 프로세스를 하나 만들낸 후 새로 변경된 메모리 페이지를 복사해서 사용한다.
3. 레디스는 copy-on-write 방식을 사용하고 있지만, 보통 레디스를 사용할 때는 데이터 변경이 잦기 때문에 실제 메모리 양만큼의 메모리를 자식 프로세스가 복사하게 된다.
4. 그래서 실제로 필요한 메모리 양보다 더 많은 메모리를 사용하게 된다.
5. 레디스는 메모리를 직접 처리할 수 없어서, 메모리 파편화가 발생하기 쉽다.

### Memcached 장점

1. memcached는 DB / API 통신을 줄이기 위해 데이터를 캐싱처리하는 데에 사용하면 좋은 캐시이다.
2. 레디스는 트래픽이 몰리면, 응답속도가 불안정하다고 한다.
3. 반면, 트래픽이 몰려도 Memcached의 응답 속도는 안정적인 편이라고 한다.
4. memcached는 내부적으로 slab 할당자를 사용하고 있어서, 메모리 파편화 문제가 덜하다.
5. 그러나, 데이터 변경이 잦은 경우, 메모리 파편화가 발생하기 쉽다. 때문에 memcached는 한 번 입력후, 변경되지 않는 정보를 저장할 때 유용하다.
6. 레디스에 비하면 메타 데이터를 적게 사용하기 때문에 메모리 사용량이 상대적으로 낮다.

### Memcached 단점

1. 레디스처럼 데이터 타입과 API가 다양하지 않다.

### 결론

1. memcached나 redis나 성능 차이가 크지 않다.
2. redis으로 통일해서 사용하는게 관리 및 확장성 측면에서 좋을 것 같다.
3. 메모리가 날아가면 서비스 장애가 발생할 수 있는 상황이라면, Redis
4. 메모리가 날라가도, 원본 데이터로 즉시 복구할 수 있는 데이터는 Memcached
5. 통신 속도를 향상 시키기 위한 목적이면 Memcached
6. 서비스의 특정 기능을 위한 목적으로 캐시 데이터를 사용한다면, Redis

## Session과 Cookie

### Session과 Cookie 사용 이유

현재 우리가 인터넷에서 사용하고 있는 HTTP프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이에 따라 HTTP프로토콜을 이용하게 되는 웹사이트에서는 웹페이지에 특정 방문자가 머무르고 있는 동안에 그 방문자의 상태를 지속시키기 위해 쿠키와 세션을 이용한다.

### Session

- 특정 웹사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한번의 방문을 의미한다.
- Session에 관련된 데이터는 Server에 저장된다.
- 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제시 사라진다.
- Cookie에 비해 보안성이 좋다.

### Cookie

- 사용자 정보를 유지할 수 없다는 HTTP의 한계를 극복할 수 있는 방법
- 인터넷 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보이다.
- Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써, Server가 아닌 Client에 텍스트 파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.
- Cookie는 Client PC에 저장되는 정보기 때문에, 다른 사용자에 의해서 임의로 변경이 가능하다.(정보 유출 가능, Session보다 보안성이 낮은 이유)

### 보안성이 낮은 Cookie 대신 Session을 사용하면 되는데 안하는 이유?

모든 정보를 Session에 저장하면 Server의 메모리를 과도하게 사용하게 되어 Server에 무리가 감

## Get과 Post 방식

### Get 방식

- 클라이언트에서 서버로 데이터를 전달할 때, 주소 뒤에 "이름"과 "값"이 결합된 스트링 형태로 전달
- 주소창에 쿼리 스트링이 그대로 보여지기 때문에 보안성이 떨어진다.
- 길이에 제한이 있다.(=전송 데이터의 한계가 있다.)
- Post방식보다 상대적으로 전송 속도가 빠르다.

### Post 방식

- 일정 크기 이상의 데이터를 보내야 할 때 사용한다.
- 서버로 보내기 전에 인코딩하고, 전송 후 서버에서는 다시 디코딩 작업을 한다.
- 주소창에 전송하는 데이터의 정보가 노출되지 않아 Get방식에 비해 보안성이 높다.
- 속도가 Get방식보다 느리다.
- 쿼리스트링(문자열) 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스 같은 객체들의 값도 전송가능.

### Get과 Post 차이점

- Get은 주로 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용
- Post는 웹 브라우저가 웹 서버에 데이터를 전달하기 위해 사용.
- Get을 사용하면 웹 브라우저에서 웹 서버로 전달되는 데이터가 인코딩되어 URL에 붙는다.
- Post방식은 전달되는 데이터가 보이지 않는다.
- Get방식은 전달되는 데이터가 255개의 문자를 초과하면 문제가 발생할 수 있다.
- 웹서버에 많은 데이터를 전달하기 위해서는 Post 방식을 사용하는 것이 바람직하다.

## MVC 패턴

### MVC란?

- 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다.
- MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.

### MVC 구성요소

Model - 소프트웨어 응용과 그와 관련된 고급 클래스 내의 논리적 데이터 기반 구조를 표현. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.
View - 사용자 인터페이스 내의 구성요소들을 표현(사용자에게 보여지는 화면)
Controller - Model과 View를 연결하고 있는 클래스를 대표, Model과 View 내의 클래스들 간 정보 교환하는데 사용.

## rest API

| num | 의미                                                                         |
| --- | ---------------------------------------------------------------------------- |
| 200 | 일반적인 성공, Reponse Body에 조회, 생성 또는 수정한 데이터를 첨부           |
| 304 | 자원을 조회 할 시, 이전과 변동 사항 없음 (클라이언트가 캐싱을 제공하는 경우) |
| 400 | 잘못된 요청, Response Body에 오류의 구체적인 정보를 첨부 할 수 있음          |
| 401 | 인증이 필요함                                                                |
| 403 | (인증이 되었으나) 권한 없음                                                  |
| 404 | 자원이 존재하지 않음                                                         |
| 500 | 서버 오류                                                                    |

### RESTful

Representational State Transfer의 약자, REST를 지킨 서비스 디자인
REST 구성 (자원 = URI, 명령= HTTP Method , 표현 = Representations)

### REST(State Transfer)의 Stateless

상태가 없다함은 하나의 요청이 그 자체로 고립되고 완전하여, 요청하는 유저의 상태(인증 등)를 세션 등으로 서버에서 관리하지 않으며, 요청 데이터 그 자체만을 해석해 응답한다는 의미.
즉, 서버에서 클라이언트의 상태를 관리하지 않아야한다. State Transfer는 요청/응답 간에 상태 관리가 필요한 경우에, 메세지 자체에 그 상태를 포함하여 통신한다는 의미로 볼 수 있다.
서버 측에서 url, 혹은 헤더에 포함된 key로 신원을 확인해야 한다.

## JWT (JSON Web Token)

서버는 API 호출 요청에 대해서 API KEY나 Token(다를바 없이 암호화된 무작위 문자열)이 유효한지를 확인 할 필요가 있다. 이는 서버에서 클라이언트의 상태(토큰의 유효성)를 관리하게끔 하며, 또 API를 호출 할 때마다 그 토큰에 해당하는 유저의 상태를 열람(DB 등에서)하는 비용을 발생시킨.
이 상황의 근본적인 이유는 토큰 자체가 무의미한 문자열로 구성되어있기 때문이다. 여기서 무의미한 토큰을 의미(유저의 상태를 포함한)가 있는 토큰으로 구성한다면, API 서버 쪽의 비용을 절감하면서 Stateless한 아키텍쳐를 구성 할 수 있다. JWT (JSON Web Token)는 유저의 상태(고유 번호, 권한, 토큰 만료 일자 등을 포함)를 JSON 포맷으로 구성하고, 이 텍스트를 다시 특정 알고리즘(Base 64)에 따라 일련의 문자열로 인코딩한 토큰을 의미한다.
JWT는 클라이언트가 본인의 상태를 서버에게 전달해주는 방식이기에 토큰 위변조 문제가 있다. 서버는 토큰의 위변조를 방지하기 위해서, 토큰의 뒷 부분에 토큰의 내용과 특정 암호(secret key)를 기반으로 Signature 문자열을 붙혀서 토큰을 생성하게 된다. 이를 통해서 서버는 클라이언트에게 상태 관리를 위임하면서도, 토큰의 위변조를 방지 할 수 있다.

## Oauth

1. 서비스 소비자(Consumer)는 서비스 제공자(Provider)가 제공하는 고객(User)의 특정 정보에 대한 API를 이용하기 위해서 Provider에게 User의 위임장(Request Token)을 생성해주길 요청합니다.
2. Provider가 Consumer에게 위임장을 생성해주면, Consumer는 다시 User에게 제공 받은 위임장을 확인해주길 요청 (Provider에 로그인하고, Consumer가 요구하는 권한을 인가하는 등)합니다.
3. User가 위임장을 확인 및 수락하면, Provider는 Consumer에게 위임에 대한 확인서(Access Token)를 발급해 줍니다.
4. 이후 Consumer는 그 확인서가 유효한 동안, 위임 받은 권한을 이용해 Provider의 API를 호출합니다.

## Netty

자바로 서버 프로그래밍 할 때 동기(블로킹) 성격을 비동기(논블로킹) 방식으로 사용할 수 있음

## 분산구조

1. pm2 포트 별로, pm2 클러스터, node.js 클러스터
2. nginx - round robin, least_conn, ip_hash(소켓.io에서 필수)

## 마이크로소프트 아키텍처

- 서버가 여러 대 있음
- API나 모듈들을 여러 서버에 분산
- 서버 하나에 여러 컨테이너를 두고 할수도 있음
- API가 분산되어잇으므로 서버 다운시 복구가 쉬움
- 무중단 배포(CI)가능
- 애자일하며 중앙 집중적이지 않은 팀일 수록 유리
- 깃 관리 별도로 할 수 있음(서버 엔지니어)

## 모놀리틱 아키텍쳐

- 서버 한대에 DB + API를 두고 서버 한대를 배포한다
- 회원 API, 게시판 API 등이 서버 한대에 놓음
- 서버 장애 발생 시 전체 재부팅해야 할 때도 있음
- 규모 작고, 복잡하지 않고, 팀원 소수이면 유리

## 젠킨스

깃 브랜치에 웹 훅을 걸어두어 자동 배포할 수 있게 해주는 툴
