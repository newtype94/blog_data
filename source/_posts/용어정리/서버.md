---
title: 용어 정리 - 서버
date: 2019-09-10 13:11:11
tags:
  - 서버
category:
  - 용어 정리
  - 서버
---

# CI/CD

- Continuous Integration : 개발자를 위한 자동화 프로세스
- Continuous Delivery, Continuous Deployment : 개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스함

# Redis와 Memchached

## Redis

1. 메모리 뿐 아니라 디스크에도 데이터를 기록하여 유사시 데이터를 복구할 수 있다.
2. String, List, Set, Sorted sets, Hash 등의 데이터 포맷 지원
3. 한 개의 키에 저장할 수 있는 용량이 Redis는 512MB, memcached는 1MB
4. 레디스는 싱글 스레드이다. 그래서 스냅샷을 뜰 때, 자식 프로세스를 하나 만들고 새로 변경된 메모리 페이지를 복사해서 사용한다.

## Memcached

1. DB/API 통신 간 데이터를 캐싱하여 처리 속도 증가
2. 데이터 변경이 잦은 경우, 메모리 파편화가 발생하기 쉽다. 그래서 memcached는 한 번 입력후 변경되지 않는 정보를 저장할 때 유용하다.
3. 레디스처럼 데이터 타입과 API가 다양하지 않다.

## 상황 별 사용

1. 메모리가 날아가면 서비스 장애가 발생할 수 있는 상황이라면, Redis
2. 메모리가 날라가도, 원본 데이터로 즉시 복구할 수 있는 데이터는 Memcached
3. 통신 속도를 향상 시키기 위한 목적이면 Memcached
4. 서비스의 특정 기능을 위한 목적으로 캐시 데이터를 사용한다면, Redis

# Session과 Cookie

## Session과 Cookie 사용 이유

HTTP프로토콜은 연결 지향적인 성격이 아니다.
매번의 페이지 요청마다 구 요청과 신 요청 사이에 연관성이 없다.
따라서 특정 도메인에 사용자가 머무르고 있는 동안, 그 사용자의 상태를 유지하기 위해 쿠키와 세션이 필요하다.

## Session

- Server, 웹 브라우저의 캐시에 저장
- 브라우저가 닫히거나 서버에서 삭제시 세션 종료
- Cookie에 비해 보안성이 좋다
- JS의 sessionStorage로써 브라우저에 저장

## Cookie

- Cookie : 인터넷 사용자가 웹서버에 접속할 때 생성되는 아이디와 비밀번호, 토큰, 방문한 사이트의 정보 등을 client에 텍스트로서 저장
- 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.
- 변조 가능, 정보 유출 가능(보안성 약함)
- JS의 localStorage로써 브라우저에 저장

# Get / Post

## Get

- 클라이언트에서 서버로 데이터를 전달할 때, 주소 뒤에 "이름"과 "값"이 결합된 스트링 형태로 전달(데이터가 인코딩되어 URL에 붙는다)
- 주소창에 쿼리 스트링이 그대로 보여지기 때문에 보안성이 떨어짐
- 길이에 제한이 있다.(255자)
- Post방식보다 전송 속도가 빠르다.
- 주로 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용

## Post

- 서버로 보내기 전에 인코딩하고, 전송 후 서버에서는 다시 디코딩 작업을 한다.
- 웹 브라우저가 웹 서버에 데이터를 전달할 때 사용
- string 뿐만 아니라, 라디오 버튼, 텍스트 박스 같은 객체(input)들의 값도 전송가능.

# MVC 패턴

- Model-View-Controller의 약자로, 3가지 역할을 나누어 개발하는 방법론

1. Model - 데이터베이스 테이블, 알고리즘 등 논리적 데이터 구조를 표현.
2. View - 사용자 인터페이스 내의 구성요소들을 표현(사용자에게 보여지는 화면)
3. Controller - Model과 View을 연결하고, 그 사이에 정보를 교환. 화면 처리 기능. 프레임워크에서 주로 라우터의 역할

# REST(Representational State Transfer)

| num | 의미                                                                         |
| --- | ---------------------------------------------------------------------------- |
| 200 | 요청 성공, Reponse Body에 내용 첨부                                          |
| 304 | 자원을 조회 할 시, 이전과 변동 사항 없음 (클라이언트가 캐싱을 제공하는 경우) |
| 400 | 잘못된 요청, Response Body에 오류 내용 첨부 가능                             |
| 401 | 인증이 필요함                                                                |
| 403 | (인증이 되었으나) 권한 없음                                                  |
| 404 | 자원이 존재하지 않음                                                         |
| 500 | 서버 오류                                                                    |

REST를 지키면 RESTFUL API가 됨

1. 자원 - HTTP URI
2. 명령 - HTTP Method
3. 표현 - HTTP Message Pay Load

http method

1. GET / 조회 / payload x
2. POST / 생성
3. PUT / 리소스 전체 교체
4. PATCH / 리소스 일부 수정
5. DELETE / 삭제 / payload x

Stateless

- 요청하는 유저의 상태(인증 등)를 서버에서 세션으로서 관리하지 않는다.
- 서버 측에서 url, 혹은 헤더에 포함된 key로 신원을 확인해야 한다.

# JWT (JSON Web Token)

## rest API

rest API 서버는 각 요청의 헤더에 포함된 API KEY나 Token을 검증한다.
그 토큰으로 유저의 상태를 DB를 통해 열람한다면 비용과 시간이 발생한다.

## 제작 방법

- 유저의 상태(user id, 권한, 토큰 만료 시간)로 JSON을 구성
- Base 64 알고리즘으로 문자열로 반환되게 인코딩

## 위변조방지

- 클라이언트 측에서 보내는 토큰이기에 위변조 위험성이 있다.
- 토큰의 뒷 부분에 토큰의 내용과 서버만 아는 secret key를 기반으로 Signature 문자열을 붙혀 토큰을 생성한다.
- 클라이언트는 받은 토큰이 만료되면 임의로 조작할 수 없고, 새로 발급받아야만 한다.

# Oauth

1. Consumer(플랫폼)은 Provider(구글)가 제공하는 User의 특정 정보에 대한 API를 이용하려고 함.
2. Consumer 가 Provider에게 User의 위임장(Request Token)을 요청
3. Consumer는 받은 위임장을 User에게 확인 요청 (Provider에 로그인)
4. User가 위임장을 확인 및 수락하면, Provider는 Consumer에게 위임에 대한 확인서(Access Token)를 발급
5. Consumer는 확인서가 유효한 동안, Provider의 API를 호출

# Netty

자바로 서버 프로그래밍 할 때 동기(블로킹) 성격을 비동기(논블로킹) 방식으로 사용할 수 있음

# 분산구조

1. 개발 차원에서 : node.js 클러스터
2. 시스템 엔지니어링 차원에서 : pm2 scale(포트 하나) || pm2 포트 별로
3. 앞 단에 nginx 도입 - round robin, least_conn, ip_hash(소켓.io에서 필수)

# 마이크로소프트 아키텍처

- 서버가 여러 대 있음
- API나 모듈들을 여러 서버에 분산
- 가능한 공유하지 않고 별도로 운영
- 서버 하나에 여러 컨테이너를 둘 수도 있음
- API가 분산되어잇으므로 서버 다운시 복구가 쉬움
- 무중단 배포(CI)가능
- 애자일하며 중앙 집중적이지 않은 팀일 수록 유리
- 깃 관리 별도로 할 수 있음

# 모놀리틱 아키텍쳐

- 학부생 때 자주 하던 토이프로젝트
- 서버 한대에 DB + API를 두고 서버 한 대를 배포한다
- 회원 API, 게시판 API 등이 서버 한 대에 존재
- 서버 장애 발생 시 재부팅 할때도 있음
- 소규모 프로젝트, 간단한 프로젝트, 팀원 소수일 경우 좋음

# Service Oriented Architecture

- 모듈의 의존성은 줄이되 모듈 내에서 공유할 수 있는건 최대한 공유
- 서비스의 Flow를 유지(MSA 는 Flow 의 구별을 요구함)
- SOA 는 서비스들의 재사용 중시 (MSA 는 서비스들의 독립을 추구)

# 젠킨스

깃 브랜치에 웹 훅을 걸어두어 자동 배포할 수 있게 해주는 툴
